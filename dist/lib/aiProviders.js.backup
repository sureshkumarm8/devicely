// AI Provider Abstraction Layer
// Supports: Google Gemini, GitHub Copilot

const { OpenAI } = require('openai');
const { GoogleGenerativeAI } = require('@google/generative-ai');
const { getPackageId, APP_MAPPINGS } = require('./appMappings');

class AIProviderManager {
  constructor() {
    this.provider = process.env.AI_PROVIDER || 'gemini'; // gemini, copilot
    this.initializeProviders();
  }

  initializeProviders() {
    // Google Gemini
    if (process.env.GEMINI_API_KEY) {
      this.gemini = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
    }

    // GitHub Copilot
    if (process.env.GITHUB_TOKEN) {
      this.copilot = new OpenAI({
        apiKey: process.env.GITHUB_TOKEN,
        baseURL: 'https://api.githubcopilot.com',
      });
    }
  }

  getSystemPrompt(platform = null) {
    // Generate app list based on platform
    let appListSection = '';
    
    if (platform === 'both') {
      // Multi-platform mode - use generic app names
      const commonApps = Object.keys(APP_MAPPINGS)
        .filter(app => APP_MAPPINGS[app].ios && APP_MAPPINGS[app].android)
        .slice(0, 30);
      
      appListSection = `\n\nMULTI-PLATFORM MODE (iOS + Android devices)
Available apps: ${commonApps.join(', ')}

IMPORTANT: Use generic app names (e.g., "launch settings", "launch chrome")
The system will automatically convert to platform-specific package IDs:
${commonApps.slice(0, 15).map(app => `- ${app} â†’ iOS: ${APP_MAPPINGS[app].ios} / Android: ${APP_MAPPINGS[app].android}`).join('\n')}

Commands will execute SIMULTANEOUSLY on all devices with correct package IDs.
`;
    } else if (platform) {
      const availableApps = Object.keys(APP_MAPPINGS)
        .filter(app => APP_MAPPINGS[app][platform])
        .slice(0, 50);
      
      appListSection = `\n\nPLATFORM: ${platform.toUpperCase()}
Available apps for ${platform}: ${availableApps.join(', ')}

APP PACKAGE MAPPINGS:
When user says "launch chrome", "open chrome", etc., use the correct package ID:
${availableApps.slice(0, 20).map(app => `- ${app} â†’ launch ${APP_MAPPINGS[app][platform]}`).join('\n')}
`;
    }
    
    return `You are a mobile device automation command converter. Convert natural language requests into executable commands for iOS and Android devices.

Available commands (work on both iOS & Android):
- launch <app_name>: Launch an app using generic name (e.g., "launch settings", "launch chrome")
- kill <app_name>: Close/force stop an app
- home: Go to home screen (press home button)
- back: Navigate back (Android/iOS)
- url <url>: Open URL in browser
- click <text>: Click on a button or element by visible text
- click <x,y>: Click at specific coordinates (e.g., click 500,1000)
- tap <text/coords>: Same as click
- longpress <text/coords>: Long press on element or coordinates
- swipe <direction>: Swipe up/down/left/right (use for scrolling)
- type <text>: Type text into focused field (just the text, no "type" prefix)
- screenshot: Take screenshot
- restart: Restart device
- rotate <left/right/portrait/landscape>: Rotate screen

iOS-specific commands:
- darkmode/lightmode: Change appearance
- airplane <on/off>: Toggle airplane mode
- wifi <on/off>: Toggle WiFi
- volume <up/down/mute>: Control volume

Android-specific commands:
- getLocators: Get all interactive elements on current screen
- recent: Open recent apps
- notifications: Open notification panel
- quicksettings: Open quick settings
${appListSection}

COMMON PHRASE MAPPINGS:
- "scroll up" OR "scroll down" â†’ swipe up OR swipe down
- "go to <url>" OR "open <url>" OR "visit <url>" â†’ url https://<url>
- "press home" OR "go home" OR "home button" â†’ home
- "open settings" OR "launch settings" â†’ launch settings
- "open camera" OR "launch camera" â†’ launch camera

Examples:
- "open chrome" â†’ launch chrome
- "launch settings" â†’ launch settings
- "open camera" â†’ launch camera
- "scroll up" â†’ swipe up
- "scroll down" â†’ swipe down
- "click on the login button" â†’ click Login
- "tap at center of screen" â†’ click 540,1000
- "swipe down" â†’ swipe down
- "type hello world" â†’ hello world
- "take a screenshot" â†’ screenshot
- "go back" â†’ back
- "press home" â†’ home
- "go to google.com" â†’ url https://www.google.com
- "visit youtube.com" â†’ url https://www.youtube.com
- "launch Chrome and search google.com" â†’ launch chrome
WAIT 3000
url https://www.google.com
- "launch settings scroll up launch camera go to google.com press home" â†’
launch settings
WAIT 3000
swipe up
WAIT 1000
home
WAIT 500
launch camera
WAIT 3000
home
WAIT 500
url https://www.google.com
WAIT 2000
home

Convert this request to commands: "{INPUT}"

CRITICAL RULES - YOU MUST FOLLOW THESE EXACTLY:
1. Output ONLY executable commands, one per line
2. NO explanations, NO markdown code blocks, NO comments, NO extra text
3. For multi-step actions, insert WAIT <milliseconds> between commands
4. Use GENERIC app names (e.g., "launch settings", "launch chrome", "launch camera")
5. Do NOT use platform-specific package IDs - use simple app names
6. The system will automatically convert to correct package IDs for each platform
5. For URLs, always use: url https://example.com
6. For scrolling, use: swipe up OR swipe down (never "scroll")
7. For text input, output ONLY the text (never include "type" prefix)
8. For home button, output: home (never "press home" or "go home")
9. WAIT timings: apps=3000ms, pages=2000ms, UI=1000ms, quick=500ms
10. Parse compound requests into individual steps with WAIT between each

OUTPUT FORMAT EXAMPLE:
launch com.apple.Preferences
WAIT 3000
swipe up
WAIT 1000
home

DO NOT include any other text. Start your response with the first command.`;
  }

  async convertCommand(text, platform = null, providerOverride = null) {
    const provider = providerOverride || this.provider;
    
    try {
      switch (provider) {
        case 'gemini':
          return await this.convertWithGemini(text, platform);
        case 'copilot':
          return await this.convertWithCopilot(text, platform);
        default:
          throw new Error(`Unknown AI provider: ${provider}`);
      }
    } catch (error) {
      console.error(`Error with ${provider}:`, error.message);
      // Re-throw the error instead of silently falling back
      // This ensures the user is aware of AI failures
      throw new Error(`AI conversion failed (${provider}): ${error.message}`);
    }
  }

  async convertWithGemini(text, platform = null) {
    if (!this.gemini) {
      throw new Error('Gemini not configured');
    }

    // Use Gemini 2.5 Flash (current stable model)
    const model = this.gemini.getGenerativeModel({ 
      model: process.env.GEMINI_MODEL || 'gemini-2.5-flash' 
    });
    
    const prompt = this.getSystemPrompt(platform).replace('{INPUT}', text);
    const result = await model.generateContent(prompt);
    const response = await result.response;
    let convertedText = response.text().trim();
    
    // Clean up AI response - remove markdown, explanations, etc.
    convertedText = this.cleanAIResponse(convertedText);
    
    return convertedText;
  }

  async convertWithCopilot(text, platform = null) {
    if (!this.copilot) {
      throw new Error('GitHub Copilot not configured');
    }

    const prompt = this.getSystemPrompt(platform).replace('{INPUT}', text);
    
    const response = await this.copilot.chat.completions.create({
      model: 'gpt-4o',
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.3,
      max_tokens: 500,
    });
    
    let convertedText = response.choices[0].message.content.trim();
    
    // Clean up AI response
    convertedText = this.cleanAIResponse(convertedText);
    
    return convertedText;
  }
  
  // Clean up AI responses - remove markdown, explanations, etc.
  cleanAIResponse(text) {
    // Remove markdown code blocks
    text = text.replace(/```[\s\S]*?```/g, '').trim();
    text = text.replace(/```/g, '').trim();
    
    // Remove any lines that look like explanations (starting with explanatory text)
    const lines = text.split('\n');
    const cleanedLines = lines.filter(line => {
      const trimmed = line.trim();
      if (!trimmed) return false;
      
      // Keep lines that are commands or WAIT
      if (trimmed.startsWith('launch ')) return true;
      if (trimmed.startsWith('kill ')) return true;
      if (trimmed === 'home') return true;
      if (trimmed === 'back') return true;
      if (trimmed.startsWith('url ')) return true;
      if (trimmed.startsWith('click ')) return true;
      if (trimmed.startsWith('tap ')) return true;
      if (trimmed.startsWith('longpress ')) return true;
      if (trimmed.startsWith('swipe ')) return true;
      if (trimmed.startsWith('WAIT ')) return true;
      if (trimmed.startsWith('screenshot')) return true;
      if (trimmed.startsWith('restart')) return true;
      if (trimmed.startsWith('rotate ')) return true;
      if (trimmed.startsWith('darkmode')) return true;
      if (trimmed.startsWith('lightmode')) return true;
      if (trimmed.startsWith('airplane ')) return true;
      if (trimmed.startsWith('wifi ')) return true;
      if (trimmed.startsWith('volume ')) return true;
      if (trimmed === 'getLocators') return true;
      if (trimmed === 'recent') return true;
      if (trimmed === 'notifications') return true;
      if (trimmed === 'quicksettings') return true;
      
      // If it doesn't start with a known command, it might be text to type
      // Check if previous line was a command that expects text input
      return true; // For now, include it (could be text to type)
    });
    
    return cleanedLines.join('\n').trim();
  }

  getAvailableProviders() {
    const available = [];
    
    if (this.gemini) available.push({ id: 'gemini', name: 'Google Gemini', icon: 'âœ¨' });
    if (this.copilot) available.push({ id: 'copilot', name: 'GitHub Copilot', icon: 'ðŸ¤–' });
    
    return available;
  }

  setProvider(provider) {
    const available = this.getAvailableProviders().map(p => p.id);
    if (available.includes(provider)) {
      this.provider = provider;
      return true;
    }
    return false;
  }

  getCurrentProvider() {
    return {
      id: this.provider,
      name: this.getProviderName(this.provider),
      available: this.getAvailableProviders(),
    };
  }

  getProviderName(providerId) {
    const names = {
      gemini: 'Google Gemini',
      copilot: 'GitHub Copilot',
    };
    return names[providerId] || 'Unknown';
  }
}

module.exports = AIProviderManager;
